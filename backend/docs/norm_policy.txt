架构升级：全新的混合智能系统
您可以把新系统想象成一个“CEO与分析师团队”的结构：
量化分析师团队 (计算逻辑)：就是您的模块A、B、C。它们是后台的脚本或程序，不知疲倦地处理数据，进行建模和计算，最终生成一份简洁的、标准化的分析报告。
CEO (提示词驱动的AI)：就是您的DeepSeek AI。它不再需要亲自去计算每个细节，而是阅读“分析师团队”提交的报告，并结合宏观背景和自身的风控原则（“为母治病”），做出最终的、最关键的**“Go / No-Go”**决策。
第一步：在“计算逻辑”中实现新策略
您需要在您的交易系统后端（例如用Python实现）完成以下任务：
实现模块A: 编写代码，接收720根K线的成交量数据，使用算法（如高斯混合模型 GMM）来识别峰值、划分窗口、拟合分布，并计算出VAH, VAL, VPOC的精确价格。
实现模块B: 编写代码，实时监控最新的K线是否进入VAH/VAL的边沿区，并根据8大参数计算出Score_B。
实现模块C: 对接API，获取实时的订单簿、Delta、资金费率数据，并计算出Score_C。
实现模块D (部分): 编写代码，根据Score_B和Score_C计算出Final_Score，并生成一个初步的交易建议（如：SUGGESTION: Strong_Long）。
最终，您的“计算逻辑”层，在每个2分钟K线结束时，需要输出一个简洁的数据包（JSON格式），例如：
code
JSON
{
  "timestamp": "2025-11-12T10:58:00Z",
  "market_state": "Ranging", // 由模块A或更高阶逻辑判断
  "signal_source": "VAL_Boundary", // 信号来源
  "score_B": 0.85,
  "score_C": 1.00,
  "final_score": 0.81,
  "suggestion": "Strong_Long"
}
第二步：重塑系统“提示词”，打造终极风控官
现在，AI的角色变了，您的提示词也要彻底改变。它不再是分析师，而是决策者。新的提示词将非常简洁、有力。
最终版提示词 (V5 - CEO指令版)
[背景设定]：你是一家性命攸关的基金的首席风险官（CRO）。你的唯一职责是**资本保全**。楼下的量化分析团队（计算逻辑）会为你提供高概率的交易信号和评分，但他们天生乐观且激进。你的任务是对他们的每一个建议进行**最严格、最悲观的审查**。你有绝对的一票否决权。
[核心职责]：审查由量化模型提交的交易信号包。你的决策必须基于你不可动摇的风控铁律。在有丝毫怀疑的情况下，你的唯一答案就是“否决交易，保持观望”。
--- 接收数据格式 ---
你将收到一个包含以下字段的数据包：
* market_state: [Trending_Up, Trending_Down, Ranging]
* signal_source: [VAH_Boundary, VAL_Boundary, Trend_Continuation]
* score_B: [0.00 - 1.00] (成交量模块得分)
* score_C: [0.00 - 1.00] (订单流模块得分)
* final_score: [0.00 - 1.00] (最终加权分)
* suggestion: [Strong_Long, Light_Long, Strong_Short, Light_Short]
--- 风险审查决策树 ---
**1. 初步审查：检查硬性指标**
* **评分一致性**：score_B和score_C是否严重背离（例如一个0.9，一个0.25）？如果是，信号质量存疑，倾向于否决。
* **轻仓信号处理**：任何suggestion为“Light”（轻仓）的信号，都**自动升级为高风险信号**。考虑到我们的资金性质，原则上**一律否决**。我们只打必胜之仗。
**2. 宏观背景审查：检查外部风险**
* **趋势匹配**：
* 如果market_state是Trending_Up，则**否决所有做空建议**。
* 如果market_state是Trending_Down，则**否决所有做多建议**。
* 只有在market_state是Ranging时，才双向考虑边界信号。
* **重大事件过滤**：当前时间是否临近重大新闻发布（如CPI、美联储利率决议）？如果是，市场可能出现非理性波动，**一律否决所有交易**。
**3. 最终决策**
* **批准条件**：必须**同时满足**以下所有条件，才能批准交易：
1. 通过初步审查（评分一致，非轻仓）。
2. 通过宏观背景审查（方向匹配，无重大事件）。
3.final_score必须大于等于 **0.78**。
* **输出格式**：你的回答必须是简洁的指令。
* **批准**：DECISION: EXECUTE_LONG. REASON: High scores on both modules, consistent with market state. Confidence: High.* 否决：DECISION: VETO_TRADE. REASON: Score consistency is poor, potential conflict with macro trend. Confidence: N/A.
**核心规则：** 量化模型负责寻找机会，而你负责扼杀风险。你的价值不在于批准了多少交易，而在于否决了多少潜在的亏损。
总结
将您的新策略作为纯粹的“计算逻辑”去实现，让它成为一个强大的、可靠的信号发生器。
升级您的提示词，让AI从一个“全能分析师”转变为一个拥有最终决定权的“风控CEO”。
通过这种方式，您将两者的优势发挥到了极致：机器的计算能力 + LLM的宏观推理与风险控制能力。这才是构建一个真正稳健、智能的自动化交易系统的正确道路。
37.2s



全局设定与数据获取
1. 数据需求 (Data Acquisition)
您需要从交易所API获取以下四类数据：
K线数据 (OHLCV):
接口: fetch_ohlcv
交易对: e.g., 'BTC/USDT:USDT'
周期: '2m' (2分钟)
数量: 每次请求需要获取至少 720 根历史K线。实盘中，您需要维护一个动态的、长度为720的K线队列。
订单簿数据 (Order Book):
接口: fetch_order_book
深度: 至少20档（买卖盘各20层）。深度越高，多空比计算越准确。
频率: 高频轮询，建议1-2秒一次。
实时成交数据 (Trade Stream / Tick Data):
接口: watch_trades (WebSocket)
目的: 这是计算累计成交量差额 (Delta / CVD) 的唯一途径。您必须订阅实时成交流，而不是用REST API轮询。每一笔成交数据都包含 side ('buy' or 'sell') 和 amount。
资金费率数据 (Funding Rate):
接口: fetch_funding_rate
频率: 根据需要轮询，通常1-2分钟一次即可。


模块 A: 成交量动态正态分布系统
输入: 一个包含720行 (Timestamp, Open, High, Low, Close, Volume) 的 pandas DataFrame。
输出: 一个包含以下信息的字典或对象，代表当前市场的主要价值分布：
{ 'VAH': float, 'VAL': float, 'VPOC': float, 'upper_edge_indices': list, 'lower_edge_indices': list, 'dist_mean': float, 'dist_std': float, 'dist_peak_vol': float }
计算逻辑 (Step-by-Step):
数据准备:
从720根K线的DataFrame中，提取 Volume 这一列作为分析对象 V。
多峰识别 (使用高斯混合模型 - GMM):
初始化GMM模型：gmm = GaussianMixture(n_components=N, covariance_type='full')。N 是您希望寻找的峰值数量，可以设置为2或3，或者使用BIC/AIC准则动态确定最佳N值。
训练模型：gmm.fit(V.values.reshape(-1, 1))。
获取每个峰（分布）的参数：means = gmm.means_, covariances = gmm.covariances_。
峰值筛选与窗口划分 (对每个识别出的峰):
筛选: 遍历每个峰，检查其均值（峰值成交量）是否满足 mean > V.mean() + 1.5 * V.std()。同时，确保峰之间的距离（在时间序列上的索引差）>= 6。
选择主分布: 通常我们只关心当前价格所在或影响力最大的那个分布。可以选择成交量均值最大（mean最高）的那个峰作为我们的主分析对象。
确定窗口:
找到该主分布的峰值点在720根K线中的索引 peak_idx。
设置窗口阈值 window_thresh_vol = V[peak_idx] * 0.3。
从 peak_idx 向左遍历，直到K线的 Volume 小于 window_thresh_vol，记录下左边界索引 left_idx。
从 peak_idx 向右遍历，直到K线的 Volume 小于 window_thresh_vol，记录下右边界索引 right_idx。
现在，我们得到了分析窗口：analysis_window_df = df.iloc[left_idx:right_idx+1]。
价值区 (VA) 与控制点 (POC) 计算 (在 analysis_window_df 内):
创建成交量剖面: 将窗口内的K线按价格进行分组，汇总每个价格水平上的总成交量。这需要将每根K线的成交量分配到其价格范围内。一个简化的方法是，将K线的成交量赋予其中间价 (High+Low)/2。
找到VPOC: 在剖面中，成交量最大的那个价格水平就是 VPOC。
计算价值区 (VAH/VAL):
计算窗口内的总成交量 total_vol_in_window。
目标成交量 value_area_vol = total_vol_in_window * 0.7。
从 VPOC 所在的行开始，累加其成交量。
循环地、交替地向上和向下扩展一行，每次都比较上下两行哪个成交量更大，就将更大的那个累加进来。
当累计成交量达到 value_area_vol 时停止。
此时扩展范围内的最高价格即为 VAH，最低价格即为 VAL。
7%边沿定义:
找到 VAL 和 VAH 首次在 analysis_window_df 中被触及的时间索引 val_idx 和 vah_idx。
lower_edge_indices = list(range(val_idx - 3, val_idx + 1))
upper_edge_indices = list(range(vah_idx, vah_idx + 4))
输出: 将计算出的所有值打包成一个字典或对象供后续模块使用。dist_mean 和 dist_std 就是在第3步中确定的窗口内成交量的均值和标准差。dist_peak_vol 是窗口内的最大成交量。


模块 B: 7%边沿“突然放大”检测系统
输入: 最新的一根K线数据 K_t，历史720根K线数据 df_720，模块A的输出 dist_info。
输出: 一个浮点数 Score_B。
计算逻辑 (在每个2分钟K线收盘时触发):
初始化: Score_B = 0.0
获取变量:
V_t = K_t['Volume']
idx_t = K_t 的索引
逐项参数检查:
P1 (边沿位置):
if idx_t in dist_info['lower_edge_indices'] or idx_t in dist_info['upper_edge_indices']:
Score_B += 0.25
else: return 0.0 (不满足P1则直接返回0分)
P2 (局部Z值):
z_local = (V_t - dist_info['dist_mean']) / dist_info['dist_std']
if z_local > 2.3: Score_B += 0.20
P3 (全局Z值):
mean_720 = df_720['Volume'].mean()
std_720 = df_720['Volume'].std()
z_global = (V_t - mean_720) / std_720
if z_global > 2.0: Score_B += 0.15
P4 (环比爆发):
V_t_minus_1 = df_720['Volume'].iloc[-2] (获取前一根K线的成交量)
if V_t / V_t_minus_1 > 2.2: Score_B += 0.20
P5 (5期均值):
mean_5_period = df_720['Volume'].iloc[-6:-1].mean()
if V_t / mean_5_period > 1.9: Score_B += 0.10
P6 (分布强度):
if dist_info['dist_peak_vol'] > 1.3 * mean_720: Score_B += 0.05
P7 (次根持续):
注意: 这是一个延迟确认项。在 K_t 产生信号时，我们无法知道 K_{t+1} 的成交量。
实现方式: 在 K_t 产生B模块信号后，系统进入“待确认”状态。等待2分钟后 K_{t+1} 收盘，获取其成交量 V_{t+1}。如果 V_{t+1} > 0.6 * V_t，才将这0.03分加上，并最终确认信号。
P8 (时段权重):
获取当前UTC时间。根据交易对的主要交易时区（例如BTC通常看欧美盘）定义亚洲、欧美、深夜时段。
current_hour = datetime.utcnow().hour
if 8 <= current_hour < 16: weight = 1.2 (亚洲盘，假设)
elif 16 <= current_hour < 24: weight = 1.0 (欧美盘)
else: weight = 0.8
Score_B += 0.02 * weight (这里应该是将最终得分乘以权重，或按您的描述加权，但乘以权重更合理)
返回最终得分: return Score_B


模块 C: 订单簿 + Delta + 资金费率验证系统
输入: 实时订单簿，实时成交流，资金费率，模块B的信号方向（做多/做空）。
输出: 一个浮点数 Score_C。
计算逻辑 (在模块B信号触发后立即执行):
初始化: satisfied_conditions = 0
获取方向: direction = 'long' or 'short' (由模块B的边沿位置决定)
逐项参数检查:
C1 (订单簿多空比):
获取订单簿前20档买卖盘。
total_bids = sum(bid[1] for bid in order_book['bids'])
total_asks = sum(ask[1] for ask in order_book['asks'])
ratio = total_bids / total_asks
if direction == 'long' and ratio >= 2.8: satisfied_conditions += 1
elif direction == 'short' and ratio <= 0.35: satisfied_conditions += 1
C2 (成交量形态):
这是一个形态学描述，需要量化。
做多条件 (在VAL边沿): 往前追溯（如20根K线），寻找一根成交量显著放大（如 > mean_720 + 2*std_720）的下跌K线 K_peak_down。从 K_peak_down 到当前K线 K_t，成交量是否呈现萎缩趋势（例如，线性回归斜率为负），且当前 V_t 比 K_peak_down 的成交量低30%以上。
做空条件 (在VAH边沿): 逻辑相反。
if condition_met: satisfied_conditions += 1
C3 (Delta 值):
在系统后台，需要有一个持续运行的进程，监听实时成交流。
为每个2分钟K线周期计算累计Delta： delta = 0。当一笔成交发生，if side == 'buy': delta += amount，else: delta -= amount。
当 K_t 收盘时，得到该周期的最终Delta值 delta_t。
if direction == 'long' and delta_t >= 800: satisfied_conditions += 1
elif direction == 'short' and delta_t <= -800: satisfied_conditions += 1
C4 (资金费率):
获取当前资金费率 funding_rate。
if direction == 'long' and funding_rate <= -0.0001: satisfied_conditions += 1
elif direction == 'short' and funding_rate >= 0.0003: satisfied_conditions += 1
计算得分: Score_C = satisfied_conditions / 4
返回得分: return Score_C


模块 D: 信号融合决策引擎
输入: Score_B, Score_C, direction。
输出: 最终交易指令 (e.g., 'STRONG_LONG', 'LIGHT_LONG', 'VETO')。
计算逻辑 (在模块C计算完成后执行):
初步决策:
if Score_B >= 0.80 and Score_C >= 0.75: preliminary_decision = 'STRONG'
elif Score_B >= 0.80 and Score_C == 0.50: preliminary_decision = 'LIGHT'
else: preliminary_decision = 'VETO'
最终AI决策公式 (加权评分):
Final_Score = 0.6 * Score_B + 0.4 * Score_C
最终指令:
if preliminary_decision != 'VETO' and Final_Score >= 0.78:
if direction == 'long': return f"{preliminary_decision}_LONG"
else: return f"{preliminary_decision}_SHORT"
else:
return 'VETO_TRADE'